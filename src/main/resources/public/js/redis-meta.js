window.redisConfig={
     "maxmemory-policy": "内存淘汰策略，默认noeviction 可以选择allkeys-lru、volatile-lru、allkeys-random、volatile-random、volatile-ttl",
     "aof-rewrite-incremental-fsync": "是否采取增量文件同步",
     "zset-max-ziplist-entries": "默认值128，与hash和list类似",
     "min-slaves-max-lag": "设置当一个master端的可用slave少于N个，延迟时间大于M秒时，不接收写操作",
     "maxmemory-samples": "默认值3，LRU和最小TTL策略并非严谨的策略，而是大约估算的方式，因此可以选择取样值以便检查",
     "tcp-keepalive": "指定ACKs的时间周期，单位为秒，值非0的情况表示将周期性的检测客户端是否可用，默认值为60秒",
     "stop-writes-on-bgsave-error": "最近一次save操作失败则停止写操作",
     "dir": "/opt/app/redisCluster/8209/redis_cluster/8209",
     "pidfile": "/var/run/redis.pid，redis启动后的进程ID保存文件 ",
     "dbfilename": "默认值dump.rdb，dump到文件系统中的文件名",
     "hz": "执行后台任务的频率(次数/秒)",
     "bind": "ip地址 docker 和 物理机可能不一样",
     "min-slaves-to-write": "0",
     "repl-diskless-sync": "默认不使用diskless同步方式",
     "repl-diskless-sync-delay": "无磁盘diskless方式在进行数据传递之前会有一个时间的延迟，以便slave端能够进行到待传送的目标队列中，这个时间默认是5秒",
     "repl-timeout": "默认值60，指定超时时间。注意本参数包括批量传输数据和ping响应的时间",
     "hash-max-ziplist-value": "默认值64",
     "databases": "指定数据库的数量，默认为16个，默认使用的数据库是DB 0",
     "slave-read-only": "默认从Redis是只读模式",
     "latency-monitor-threshold": "延迟监控，用于记录等于或超过了指定时间的操作，默认是关闭状态，即值为0",
     "hash-max-ziplist-entries": "ziplist中允许存储的最大条目个数,建议为128",
     "auto-aof-rewrite-percentage": "默认值100",
     "logfile": "指定日志的输出路径，默认值stdout，表示输出到屏幕，守护模式时则输出到/dev/null",
     "cluster-require-full-coverage": "若想要设置集群在部份key space没有cover完成时继续去接收查询，就将参数设置为no",
     "slaveof": "设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步",
     "maxclients": "指定客户端的最大并发连接数，默认是没有限制，直到redis无法创建新的进程为止，设置该参数值为0也表示不限制，如果该参数指定了值，当并发连接达到指定值时，redis会关闭所有新连接，并返回'max number of clients reached'的错误信息",
     "hll-sparse-max-bytes": "3000",
     "notify-keyspace-events": "事件通知，默认不启用，具体参数查看配置文件",
     "port": "端口",
     "slowlog-max-len": "慢操作日志 保留的最大条数",
     "list-max-ziplist-value": "默认值64",
     "zset-max-ziplist-value": "默认值64",
     "rdbcompression": "默认值yes，当dump数据库时使用LZF压缩字符串对象，如果CPU资源比较紧张，可以设置为no，选择不压缩",
     "unixsocket": "/tmp/redis.sock 指定监听的socket，适用于unix环境 ",
     "lua-time-limit": "lua脚本运行的最大时间",
     "appendonly": "是否开启aof功能",
     "slowlog-log-slower-than": "慢操作日志 记录,单位:微秒",
     "maxmemory": "设置最大内存，例：10485760000",
     "save": "指定多长时间刷新快照至磁盘，这个选项有两个属性值，只有当两个属性值均满足时才会触发；可以设置多种级别，例如默认的参数文件中就设置了",
     "tcp-backlog": "此参数确定TCP连接中已完成队列（3次握手之后）的长度，应小于Linux系统的/proc/sys/net/core/somaxconn的值，此选项默认值为511",
     "slave-serve-stale-data": "默认值yes",
     "timeout": "tcp链接空闲时间，超过会被关闭",
     "cluster-slave-validity-factor": "默认值为10",
     "unixsocketperm": "0",
     "activerehashing": "是否开启顶层数据结构的rehash功能,如果内存允许,请开启，默认yes",
     "repl-ping-slave-period": "默认值10，指定slave定期ping master的周期",
     "appendfsync": "aof中文件同步机制",
     "watchdog-period": "0",
     "cluster-node-timeout": "设置集群节点超时时间，如果超过了指定的超时时间后仍不可达，则节点被认为是失败状态，单位为毫秒",
     "repl-backlog-size": "设置backlog的大小，例：67108864",
     "list-max-ziplist-entries": "默认值512，与hash类似，满足条件的list数组也会采用特殊的方式以节省空间",
     "requirepass": "指定一个密码，客户端连接时也需要通过密码才能成功连接",
     "daemonize": "后台模式启动(docker 和 物理机的配置可能会不一样)",
     "auto-aof-rewrite-min-size": "aof rewrite触发时机,最小文件大小",
     "rdbchecksum": "启用CRC64校验码，当然这个会影响一部份性能",
     "aof-load-truncated": "是否加载不完整的aof文件来进行启动",
     "no-appendfsync-on-rewrite": "当主进程在进行向磁盘的写操作时，将会阻止其它的fsync调用",
     "repl-backlog-ttl": "3600， 如果一段时间后没有slave连接到master，则backlog size的内存将会被释放，如果值为0则表示永远不释放这部份内存",
     "client-output-buffer-limit": "normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60",
     "masterauth": "如果master配置了密码的话，此处也需做设置",
     "slave-priority": "slave端的优先级设置，值是一个整数，数字越小表示优先级越高",
     "repl-disable-tcp-nodelay": "是否启用TCP_NODELAY",
     "loglevel": "verbose，指定服务器信息显示的等级，4个参数分别为debug verbose notice warning ",
     "set-max-intset-entries": "默认值512，当set类型中的数据都是数值类型，并且set中整型元素的数量不超过指定值时，使用特殊的编码方式",
     "cluster-migration-barrier": "要将一个slave迁移到别的master，必须这个slave的原master端有至少给定数目的可用slave才可以进行迁移，这个给定的数目由migration barrier参数来进行设置，默认值为1"
}

window.redisInfo={
   "tcp_port": "tcp 端口",
   "uptime_in_seconds": "自 Redis 服务器启动以来，经过的秒数",
   "uptime_in_days": " 自 Redis 服务器启动以来，经过的天数",
   "blocked_clients": "正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量",
   "aof_rewrite_scheduled": "标识是否将要在rdb save操作结束后执行",
   "total_net_input_bytes": "redis网络入口流量字节数",
   "hz": "10，redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，程序规定serverCron每秒运行10次",
   "redis_build_id": "redis build id",
   "sync_partial_err": "主从部分同步失败次数",
   "aof_last_bgrewrite_status": "上次bgrewriteaof操作的状态",
   "multiplexing_api": "epoll，redis所使用的事件处理机制",
   "client_biggest_input_buf": "当前连接的客户端当中，最大输入缓存，用client list命令观察qbuf和qbuf-free两个字段最大值",
   "aof_current_rewrite_time_sec": "如果rewrite操作正在进行，则记录所使用的时间，单位秒",
   "aof_enabled": "是否开启了aof，默认不开启",
   "aof_current_size": "aof当前大小",
   "master_repl_offset": "主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟",
   "repl_backlog_first_byte_offset": "复制缓冲区里偏移量的大小",
   "used_cpu_user": "将所有redis主进程在用户态所占用的CPU时求和累计起来",
   "rdb_last_bgsave_status": "最近一次rdb持久化是否成功",
   "redis_mode": "cluster，运行模式，单机或者集群",
   "redis_git_dirty": "Git dirty flag",
   "aof_delayed_fsync": "被延迟的fsync调用数量",
   "repl_backlog_histlen": "此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小",
   "loading": "loading 状态",
   "evicted_keys": "运行以来剔除(超过了maxmemory后)的key的数量",
   "cluster_enabled": "实例是否启用集群模式",
   "redis_version": "redis服务器版本",
   "aof_last_write_status": "上次aof写入状态",
   "repl_backlog_active": "复制积压缓冲区是否开启",
   "mem_allocator": "在编译时指定的redis所使用的内存分配器。可以是libc、jemalloc或者tcmalloc",
   "detail": "# Serve",
   "used_memory_peak": "redis的内存消耗峰值(以字节为单位) ",
   "instantaneous_ops_per_sec": "redis当前的qps，redis内部较实时的每秒执行的命令数",
   "process_id": "redis服务器进程的pid",
   "used_memory_human": "以人类可读的格式返回redis分配的内存总量",
   "used_cpu_sys": "将所有redis主进程在核心态所占用的CPU时求和累计起来",
   "role": "实例的角色，是master or slave",
   "repl_backlog_size": "复制积压缓冲大小",
   "connected_slaves": "连接的slave实例个数",
   "gcc_version": "编译redis时所使用的gcc版本",
   "sync_full": "主从完全同步成功次数",
   "connected_clients": "客户端连接数",
   "used_memory_lua": "lua引擎所使用的内存大小(以字节为单位)",
   "rdb_current_bgsave_time_sec": "如果服务器正在创建rdb文件，那么这个域记录的就是当前的创建操作已经耗费的秒数",
   "aof_pending_bio_fsync": "后台I/O队列里面，等待执行的fsync调用数量",
   "total_net_output_bytes": "redis网络出口流量字节数",
   "pubsub_channels": "当前使用中的频道数量",
   "arch_bits": "架构(32或64位)",
   "rdb_changes_since_last_save": "离最近一次成功生成rdb文件，写入命令的个数，即有多少个写入命令没有持久化",
   "instantaneous_input_kbps": "redis网络入口kps",
   "mem_fragmentation_ratio": "used_memory_rss和used_memory之间的比率，小于1表示使用了swap，大于1表示碎片比较多",
   "aof_last_rewrite_time_sec": "最近一次aof rewrite耗费的时长",
   "used_cpu_sys_children": "将后台进程在核心态所占用的CPU时求和累计起来",
   "aof_rewrite_in_progress": "标识aof的rewrite操作是否在进行中",
   "config_file": "配置文件路径",
   "lru_clock": "自增的时钟，用于LRU管理,该时钟100ms(hz=10,因此每1000ms/10=100ms执行一次定时任务)更新一次",
   "sync_partial_ok": "主从部分同步成功次数",
   "rdb_last_save_time": "离最近一次成功创建rdb文件的时间戳。当前时间戳 - rdb_last_save_time=多少秒未成功生成rdb文件",
   "pubsub_patterns": "当前使用的模式的数量",
   "redis_git_sha1": "Git SHA1",
   "used_memory_rss": "从操作系统的角度，返回redis已分配的内存总量(俗称常驻集大小)。这个值和top命令的输出一致",
   "rdb_last_bgsave_time_sec": "最近一次成功生成rdb文件耗时秒数",
   "run_id": "redis服务器的随机标识符(用于sentinel和集群)",
   "latest_fork_usec": "最近一次fork操作阻塞redis进程的耗时数，单位微秒",
   "os": "redis服务器的宿主操作系统",
   "slave0": "lag从库多少秒未向主库发送REPLCONF命令",
   "rejected_connections": "拒绝的连接个数，redis连接个数达到maxclients限制，拒绝新连接的个数",
   "total_commands_processed": "redis处理的命令数",
   "expired_keys": "运行以来过期的key的数量",
   "client_longest_output_list": "当前连接的客户端当中，最长的输出列表，用client list命令观察omem字段最大值",
   "used_memory": "由redis分配器分配的内存总量，以字节为单位",
   "aof_rewrite_buffer_length": "aof rewrite buffer的大小",
   "aof_buffer_length": "aof buffer的大小",
   "keyspace_misses": "没命中次数",
   "aof_base_size": "服务器启动时或者aof重写最近一次执行之后aof文件的大小",
   "instantaneous_output_kbps": "redis网络出口kps",
   "used_memory_peak_human": "以人类可读的格式返回redis的内存消耗峰值",
   "keyspace_hits": "命中次数",
   "aof_pending_rewrite": "是否有aof重写操作在等待rdb文件创建完毕之后执行",
   "rdb_bgsave_in_progress": "服务器是否正在创建rdb文件",
   "used_cpu_user_children": "将后台进程在用户态所占用的CPU时求和累计起来",
   "total_connections_received": "新创建连接个数,如果新创建连接过多，过度地创建和销毁连接对性能有影响，说明短连接严重或连接池使用有问题，需调研代码的连接设置",
   "migrate_cached_sockets": "0"
 }
